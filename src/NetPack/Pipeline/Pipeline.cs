using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.Contracts;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Dazinator.AspNet.Extensions.FileProviders;
using Dazinator.AspNet.Extensions.FileProviders.Directory;
using Microsoft.Extensions.FileProviders;
using Microsoft.Extensions.Primitives;
using NetPack;
using NetPack.RequireJs;
using NetPack.Requirements;
using Polly;
using NetPack.Pipeline;

namespace NetPack.Pipeline
{

    public class Pipeline : IPipeLine
    {

        public static TimeSpan DefaultFlushTimeout = new TimeSpan(0, 5, 0);

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="environmentFileProvider">The file provider from the environment that allows this pipe to get it's files files from the environment for processing.</param>
        /// <param name="pipes">The processors in this pipeline.</param>
        /// <param name="requirements">Requirements that this pipeline needs to satisfy in order to process.</param>
        /// <param name="sourcesOutputDirectory">A directory in which source files can be output without triggering any further processing. This will be integrated with webroot file provider so that source files can be made available to the browser.</param>
        /// <param name="baseRequestPath">The base request path upon which any source files, or generated output will be resolved / served on via the browser.</param>
        /// <param name="directory">A directory in which any generated outputs will be placed. If null specified, then this pipeline will use its own instance. Allows multiple pipelines to share the same output directory which means an output generated by one pipeline could trigger processing in a seperate pipeline sharing the same output directory.</param>
        public Pipeline(IFileProvider environmentFileProvider,
            List<PipeContext> pipes,
            List<IRequirement> requirements,
            IDirectory sourcesOutputDirectory,
            string baseRequestPath = null,
            IDirectory directory = null)
        {
            EnvironmentFileProvider = environmentFileProvider;
            Pipes = pipes;
            Requirements = requirements;
            BaseRequestPath = baseRequestPath;
            //  IsWatching = watch;
            HasFlushed = false;
            GeneratedOutputDirectory = directory ?? new InMemoryDirectory();
            GeneratedOutputFileProvider = new InMemoryFileProvider(GeneratedOutputDirectory);
            SourcesOutputDirectory = sourcesOutputDirectory ?? new InMemoryDirectory();
            SourcesFileProvider = new InMemoryFileProvider(sourcesOutputDirectory);
            InputAndGeneratedFileProvider = new CompositeFileProvider(EnvironmentFileProvider, GeneratedOutputFileProvider);
            WebrootFileProvider = new CompositeFileProvider(GeneratedOutputFileProvider, SourcesFileProvider);
            Context = new PipelineContext(
                InputAndGeneratedFileProvider,
                SourcesOutputDirectory, GeneratedOutputDirectory, BaseRequestPath);
            // Name = Guid.NewGuid().ToString();
        }

        protected PipelineContext Context { get; set; }

        /// <summary>
        /// Provides access to files that need to be processed from the environment. 
        /// This does not include access to new files that are produced only as a result of pipeline processing.
        /// </summary>
        public IFileProvider EnvironmentFileProvider { get; set; }

        /// <summary>
        /// Provides access too all generated output files only. These are files that were output as a result of file processing some input files.
        /// </summary>
        public IFileProvider GeneratedOutputFileProvider { get; set; }

        /// <summary>
        /// Provides access to the subset of input / source files that need to be served up to the borwser, usually the case if sourcemaps are in play without inline sources.
        /// </summary>
        public IFileProvider SourcesFileProvider { get; set; }

        /// <summary>
        /// Provides access too all un-processed output files only. These are basically input files that need to be seen by the brwoser, but on which
        /// no processing occurred. For example, a processor that compiles typescript input files, and produces js output files may need to also 
        /// ensure the orgiginal typescript files can be served up to the browser when source maps are enabled. The typescript files are the original
        /// input files and no actual changes are being made to those files so they are placed in the UnprocessedOutputFileProvider which
        /// get's integrated with the Environments WebRoot file provider so that the files can be resolved.
        /// </summary>
        public IDirectory SourcesOutputDirectory { get; set; }

        /// <summary>
        /// Provides access input files and generated files.
        /// </summary>
        public IFileProvider InputAndGeneratedFileProvider { get; set; }

        /// <summary>
        /// Provides access to all files that should be visible to webroot - i.e a browser.
        /// </summary>
        public IFileProvider WebrootFileProvider { get; set; }

        /// <summary>
        /// The directory for all generated files.
        /// </summary>
        public IDirectory GeneratedOutputDirectory { get; set; }

        /// <summary>
        /// The configured pipes in this pipeline.
        /// </summary>
        public List<PipeContext> Pipes { get; set; }

        /// <summary>
        /// Requirements that must be met for this pipeline to function.
        /// </summary>
        public List<IRequirement> Requirements { get; set; }

        private string _baseRequestPath;
        public string BaseRequestPath
        {
            get { return _baseRequestPath; }
            set
            {
                _baseRequestPath = value;
                //Output.SetRequestPaths(_requestPath);
            }
        }

        public void Initialise()
        {
            // run checks for requirements.
            EnsureRequirements();
            // Trigger the pipeline to be flushed if it hasn't already.
            // we want to block becausewe dont want the app to finish starting
            // before all assets have been processed..
            if (!HasFlushed)
            {
                //todo: exception handling here.
                ProcessAsync(CancellationToken.None).Wait(DefaultFlushTimeout);
                // await pipeline.FlushAsync();
            }
        }

        private void EnsureRequirements()
        {
            foreach (var requirement in Requirements)
            {
                requirement.Check();
            }
        }

        /// <summary>
        /// Processes all pipes.
        /// </summary>
        /// <returns></returns>
        public Task ProcessAsync(CancellationToken cancelationToken)
        {
            return ProcessPipesAsync(Pipes, cancelationToken);
        }

        public async Task ProcessPipesAsync(IEnumerable<PipeContext> pipeContexts, CancellationToken cancellationToken)
        {
   //         var policy = Policy.Handle<IOException>()
   //                  .WaitAndRetryAsync(new[]
   //{
   // TimeSpan.FromSeconds(1),
   // TimeSpan.FromSeconds(2),
   // TimeSpan.FromSeconds(3)
   //}, (exception, timeSpan) =>
   //{
   //    // TODO: Log exception    
   //});

            try
            {

                foreach (var pipeContext in pipeContexts)
                {
                    await Context.Apply(pipeContext, cancellationToken);
                }

                FlushCount = FlushCount + 1;
                HasFlushed = true;
            }
            catch (Exception e)
            {
                // retry?
                throw;
            }
        }

        public IEnumerable<PipeContext> GetDirtyPipes()
        {
            var dirty = Pipes.Where(a => a.IsDirty());
            return dirty;
        }

        public int FlushCount { get; set; }

        public bool HasFlushed { get; set; }

    }


}


